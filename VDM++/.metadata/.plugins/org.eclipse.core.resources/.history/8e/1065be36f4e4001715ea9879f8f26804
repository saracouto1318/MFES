class Hospital
types
	public String = seq of(char);
instance variables
  public medicalAssociated: set of (MedicalAssociated);
  public name: String;
  public address: String;
  public tasks: set of(Task);
 
 inv card medicalAssociated > 0;
 inv card tasks > 0;
operations

	public Hospital: String * String ==> Hospital
		Hospital(n, a) == (name := n; address := a; medicalAssociated := {}; tasks := {}; return self)
	pre n <> [] and a <> []
	post name = n and address = a and medicalAssociated = {} and tasks = {};
	
	pure public getName: () ==> String
		getName() == (return name);
	
	pure public getAddress: () ==> String
		getAddress() == (return address);
		
	pure public getMedicalAssociated: () ==> set of (MedicalAssociated)
		getMedicalAssociated() == (return medicalAssociated);
		
	pure public getTasks: () ==> set of (Task)
		getTasks() == (return tasks);
	
	pure public getMedAssociated: String ==> MedicalAssociated
		getMedAssociated(n) == (
																			dcl medical: MedicalAssociated;
																			for all m in set medicalAssociated do
																				if(m.getName() = n)
																					then medical := m;
																					
																			return medical;
																	)
	pre n <> [];
	
	pure public addMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
		addMedAssociated(d) == (return ({d} union medicalAssociated))
	pre d not in set medicalAssociated
	post d in set medicalAssociated;
		
	pure public removeMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
		removeMedAssociated(d) == (return (medicalAssociated \ {d}))
	pre d in set medicalAssociated
	post d not in set medicalAssociated;
	
	pure public addTask: Task ==> set of (Task)
		addTask(d) == (return ({d} union tasks))
	pre d not in set tasks
	post d in set tasks;
		
	pure public removeTask: Task ==> set of (Task)
		removeTask(d) == (return (tasks \ {d}))
	pre d in set tasks
	post d not in set tasks;
	
	pure public getAppointments: () ==> set of (Task)
		getAppointments() == (
														dcl tasks2: set of (Task);
														for all t in set tasks do
															if(t.getType() = "Appointment")
																then tasks2 := tasks2 union {t};
														return tasks2);

	pure public getDoctors: () ==> set of (Doctor)
		getDoctors() == (
											dcl doctors: set of (Doctor);
											for all d in set medicalAssociated do
												if(d.getType() = "Doctor")
													then doctors := doctors union {d};
													
											return doctors);
											
	
end Hospital
