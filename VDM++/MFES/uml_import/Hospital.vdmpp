class Hospital
instance variables
  private medicalAssociated: set of (MedicalAssociated);
  private name: Types`String;
  private address: Types`String;
  private tasks: set of(Task);
  private trainings: set of(Training);
  private safetyNet: [SafetyNetHospital];
 
 inv name <> [] and address <> [];
 inv safetyNet <> nil; 
 inv card medicalAssociated >= 0;
 inv card tasks >= 0;
operations

	public Hospital: Types`String * Types`String * SafetyNetHospital ==> Hospital
		Hospital(n, a, s) == (name := n; address := a; safetyNet := s; medicalAssociated := {}; tasks := {}; trainings := {}; return self)
	pre n <> [] and a <> [] and safetyNet <> nil
	post name = n and address = a and safetyNet = s and medicalAssociated = {} and tasks = {} and trainings = {};
	
	pure public getName: () ==> Types`String
		getName() == (return name);
	
	pure public getAddress: () ==> Types`String
		getAddress() == (return address);
		
	pure public getSafetyNet: () ==> SafetyNetHospital
		getSafetyNet() == (return safetyNet);
	
	pure public addMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
		addMedAssociated(d) == (return ({d} union medicalAssociated))
	pre d not in set medicalAssociated
	post d in set medicalAssociated;
		
	pure public removeMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
		removeMedAssociated(d) == (return (medicalAssociated \ {d}))
	pre d in set medicalAssociated
	post d not in set medicalAssociated;
	
	public addTask: Task ==> set of (Task)
		addTask(d) == (return ({d} union tasks))
	pre d not in set tasks and forall t in set tasks & 
		not (overlap(d, t) and not (d.getMedAssoc().getCC() <> t.getMedAssoc().getCC() and 
				d.getPatient().getCC() <> t.getPatient().getCC() and d.getMedAssoc().getCC() <> t.getPatient().getCC()
				and d.getPatient().getCC() <> t.getMedAssoc().getCC()))
	post d in set tasks;
		
	pure public removeTask: Task ==> set of (Task)
		removeTask(d) == (return (tasks \ {d}))
	pre d in set tasks
	post d not in set tasks;
	
	public addTraining: Training ==> set of (Training)
		addTraining(d) == (return ({d} union trainings))
	pre d not in set trainings and forall t in set trainings & not (overlapTraining(d, t))
	post d in set trainings;
		
	pure public removeTraining: Training ==> set of (Training)
		removeTraining(d) == (return (trainings \ {d}))
	pre d in set trainings
	post d not in set trainings;
	
	pure public getTasksByType: Types`TaskType ==> set of (Task)
		getTasksByType(s) == (
														dcl tasksTotal: set of (Task);
														for all t in set tasks do
															if(t.getType() = s)
																then tasksTotal := tasksTotal union {t};
																
														return tasksTotal);
														
	pure public getTrainingsByType: Types`Purpose ==> set of (Training)
		getTrainingsByType(s) == (
														dcl train: set of (Training);
														for all t in set trainings do
															if(t.getPurpose() = s)
																then train := train union {t};
																
														return train);

	pure public getMedicalAssociatedByType: Types`Type ==> set of (MedicalAssociated)
		getMedicalAssociatedByType(type) == (
											dcl med: set of(MedicalAssociated);
											for all d in set medicalAssociated do
												if(d.getType() = type)
													then med := med union {d};
												
											return med);
											
	pure public overlap: Task * Task ==> bool
		overlap(t1, t2) == (
													if(t1.getSchedule().compareDate(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														or (t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														and not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleEnd(), t2.getSchedule().getScheduleStart()))
														or (not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														and t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleEnd())))
														then return true
													else
														return false);
														
	pure public overlapTraining: Training * Training ==> bool
		overlapTraining(t1, t2) == (
													if(t1.getSchedule().compareDate(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														or (t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														and not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleEnd(), t2.getSchedule().getScheduleStart()))
														or (not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
														and t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleEnd())))
														then return true
													else
														return false);
														
end Hospital
