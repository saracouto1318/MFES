\begin{vdmpp}[breaklines=true]
class Hospital
instance variables
  private medicalAssociated: set of (MedicalAssociated);
  private name: Types`String;
  private address: Types`String;
  private tasks: set of(Task);
  private trainings: set of(Training);
  private safetyNet: [SafetyNetHospital];
 
 inv name <> [] and address <> [];
 inv safetyNet <> nil; 
 inv card medicalAssociated >= 0;
 inv card tasks >= 0;
operations

 public Hospital: Types`String * Types`String * SafetyNetHospital ==> Hospital
(*@
\label{Hospital:17}
@*)
  Hospital(n, a, s) == (name := n; address := a; safetyNet := s; medicalAssociated := {}; tasks := {}; trainings := {}; return self)
 pre n <> [] and a <> [] and safetyNet <> nil
 post name = n and address = a and safetyNet = s and medicalAssociated = {} and tasks = {} and trainings = {};
 
 pure public getName: () ==> Types`String
(*@
\label{getName:22}
@*)
  getName() == (return name);
 
 pure public getAddress: () ==> Types`String
(*@
\label{getAddress:25}
@*)
  getAddress() == (return address);
  
 pure public getSafetyNet: () ==> SafetyNetHospital
(*@
\label{getSafetyNet:28}
@*)
  getSafetyNet() == (return safetyNet);
 
 pure public addMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
(*@
\label{addMedAssociated:31}
@*)
  addMedAssociated(d) == (return ({d} union medicalAssociated))
 pre d not in set medicalAssociated
 post d in set medicalAssociated;
  
 pure public removeMedAssociated: MedicalAssociated ==> set of (MedicalAssociated)
(*@
\label{removeMedAssociated:36}
@*)
  removeMedAssociated(d) == (return (medicalAssociated \ {d}))
 pre d in set medicalAssociated
 post d not in set medicalAssociated;
 
 public addTask: Task ==> set of (Task)
(*@
\label{addTask:41}
@*)
  addTask(d) == (return ({d} union tasks))
 pre d not in set tasks and forall t in set tasks & 
  not (overlap(d, t) and not (d.getMedAssoc().getCC() <> t.getMedAssoc().getCC() and 
    d.getPatient().getCC() <> t.getPatient().getCC() and d.getMedAssoc().getCC() <> t.getPatient().getCC()
    and d.getPatient().getCC() <> t.getMedAssoc().getCC()))
 post d in set tasks;
  
 pure public removeTask: Task ==> set of (Task)
(*@
\label{removeTask:49}
@*)
  removeTask(d) == (return (tasks \ {d}))
 pre d in set tasks
 post d not in set tasks;
 
(*@
\label{addTraining:53}
@*)
 public addTraining: Training ==> set of (Training)
(*@
\label{getTasksByType:54}
@*)
  addTraining(d) == (return ({d} union trainings))
 pre d not in set trainings and forall t in set trainings & not (overlapTraining(d, t))
 post d in set trainings;
  
(*@
\label{removeTraining:58}
@*)
 pure public removeTraining: Training ==> set of (Training)
  removeTraining(d) == (return (trainings \ {d}))
 pre d in set trainings
 post d not in set trainings;
 
 pure public getTasksByType: Types`TaskType ==> set of (Task)
  getTasksByType(s) == (
              dcl tasksTotal: set of (Task);
              for all t in set tasks do
               if(t.getType() = s)
                then tasksTotal := tasksTotal union {t};
                
              return tasksTotal);
              
(*@
\label{getTrainingsByType:72}
@*)
(*@
\label{getMedicalAssociatedByType:72}
@*)
 pure public getTrainingsByType: Types`Purpose ==> set of (Training)
  getTrainingsByType(s) == (
              dcl train: set of (Training);
              for all t in set trainings do
               if(t.getPurpose() = s)
                then train := train union {t};
                
              return train);

 pure public getMedicalAssociatedByType: Types`Type ==> set of (MedicalAssociated)
  getMedicalAssociatedByType(type) == (
           dcl med: set of(MedicalAssociated);
           for all d in set medicalAssociated do
            if(d.getType() = type)
             then med := med union {d};
(*@
\label{overlap:87}
@*)
            
           return med);
           
 pure public overlap: Task * Task ==> bool
  overlap(t1, t2) == (
             if(t1.getSchedule().compareDate(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              or (t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              and not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleEnd(), t2.getSchedule().getScheduleStart()))
              or (not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              and t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleEnd())))
              then return true
             else
              return false);
              
(*@
\label{overlapTraining:101}
@*)
 pure public overlapTraining: Training * Training ==> bool
  overlapTraining(t1, t2) == (
             if(t1.getSchedule().compareDate(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              or (t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              and not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleEnd(), t2.getSchedule().getScheduleStart()))
              or (not t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleStart()) 
              and t1.getSchedule().compareDateLess(t1.getSchedule().getScheduleStart(), t2.getSchedule().getScheduleEnd())))
              then return true
             else
              return false);
              
end Hospital
\end{vdmpp}
